#!/bin/bash

# Copyright 2016 David McCormick, Zopa.com
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Configuration VARS
# RUN_LOOP_DELAY seconds - the amount of time to wait before starting another run.
# VOLUME_PATH: The location of the local sparse volumes and meta-data

# Defaults
DEFAULT_PATH=/var/lib/kubelet/bounded-local
DEFAULT_LOGGING_PATH=/var/log-collection

# Access to Splunk forwarder API
SPLUNKFWD_URL=https://localhost:8089
SPLUNKFWD_USER=admin
SPLUNKFWD_PASS=changeme
CURL="/usr/bin/curl"

# Debug Logging
DEBUG="false"

[[ -z "${VOLUME_PATH}" ]] && VOLUME_PATH=${DEFAULT_PATH}
[[ ! -e "${VOLUME_PATH}" ]] && mkdir -p ${VOLUME_PATH}
[[ -z "${LOGGING_PATH}" ]] && LOGGING_PATH=${DEFAULT_LOGGING_PATH}
[[ ! -e "${LOGGING_PATH}" ]] && mkdir -p ${LOGGING_PATH}

# log to syslog...
log() {
        echo "$*"
}

# is the path a mount or not?
ismounted() {
        local MNTPATH=$1

        local MOUNT=`findmnt -n ${MNTPATH} 2>/dev/null | cut -d' ' -f1`
        [[ "${MOUNT}" == "${MNTPATH}" ]]
        return $?
}

# call the splunk forwarder REST API using curl.
splunk_api() {
  local VERB=$1
  local PATH=$2
  local EXTRAS=$3
  local RESULT=""

  local CALL="${CURL} --fail -k -s -u ${SPLUNKFWD_USER}:${SPLUNKFWD_PASS} ${SPLUNKFWD_URL}${PATH} -X ${VERB} ${EXTRAS}"
  [[ "${DEBUG}" == "true" ]] && log "Calling $CALL"
  if ! RESULT=$(eval $CALL 2>&1)
  then
    log "Splunk API CALL FAILED!"
    [[ "${DEBUG}" == "true"  ]] && log "${RESULT}"
    return 1
  else
    [[ "${DEBUG}" == "true"  ]] && log "${RESULT}"
    return 0
  fi
}


# Get an element of kubernetes metadata from a local cache or go looking
# for a downward-api volume called 'podinfo' in the pod.
get_kubeinfo() {
        local META=$1
        local VOL=$2

        if [[ -f "${VOL}/${META}" ]]; then
                cat "${VOL}/${META}"
        else
                local MNTPATH=$(cat ${VOL}/mountpath)
                local PODPATH=${MNTPATH%%/volumes/*}
                if [[ -f "${PODPATH}/volumes/kubernetes.io~downward-api/podinfo/${META}" ]]; then
                        #convert all the spaces to %20 so that multiple values are now separated by spaces.
                        cat "${PODPATH}/volumes/kubernetes.io~downward-api/podinfo/${META}" |  sed -e 's/ /%20/g' | tee ${VOL}/${META}
                else
                        echo ""
                fi
        fi
}

# read collected metadata for a pod and convert this into the syntax for defining a splunk
# _meta field.
get_splunk_metadata() {
        local VOL=$1
        local METALINE=""

        local META ELEMENT KEY VALUE METAKEY METADISPLAY

        for META in namespace::namespace podname::pod labels::label
        do
		METAKEY=${META%%::*}
		METADISPLAY=${META##*::}
                for ELEMENT in $(get_kubeinfo ${METAKEY} ${VOL})
                do
                        if [[ -n "${ELEMENT}" ]]; then
                                ELEMENT=$(echo ${ELEMENT} | sed -e 's/%20/ /g')
                                if [[ "${ELEMENT}" =~ = ]]; then
                                        # structured key=value type fields become k8s_meta_key::value
					KEY=${ELEMENT%%=*}	
					VALUE=${ELEMENT##*=}
                                        [[ -z "${METALINE}" ]] && METALINE="k8s_${METADISPLAY}_${KEY,,}::${VALUE}" || METALINE+=" k8s_${METADISPLAY}_${KEY,,}::${VALUE}"
                                else
                                        # simple value type fields become k8s_meta::value
                                        [[ -z "${METALINE}" ]] && METALINE="k8s_${METADISPLAY}::${ELEMENT}" || METALINE+=" k8s_${METADISPLAY}::${ELEMENT}"
                                fi
                        fi
                done
        done
        echo "${METALINE}"
}

escape_quotes() {
        echo $* | sed -e 's/"/\\"/g'
}

configure_splunk_monitor() {
        local VOL=$1
        local PUID=$2

        local SHORTVOL=${VOL##*/}
        local META=$(get_splunk_metadata ${VOL})
        log "Pod $PUID has meta data: ${META}"

        splunk_api POST "/services/data/inputs/monitor" "-d \"name=/applogs/${PUID}/\"" && \
        splunk_api POST "/services/properties/inputs/monitor%3A%2F%2F%2Fapplogs%2F${PUID}" "-d \"_meta=$(escape_quotes ${META})\"" && \
        splunk_api GET "/services/data/inputs/monitor/_reload"
        if [[ "$?" -eq 0 ]]; then
                log "[CHANGE] Created splunk monitor and updated with pod metadata .. ok"
                splunk_api GET /services/properties/inputs/monitor%3A%2F%2F%2Fapplogs%2F${PUID}
        else
                log "ERROR creating splunk monior!"
                return 1
        fi

        return 0
}


remove_splunk_monitor() {
        local PUID=$1

        log "Removing splunk monitor for ${PUID}"

        splunk_api DELETE "/services/properties/inputs/monitor%3A%2F%2F%2Fapplogs%2F${PUID}"  && \
        splunk_api GET "/services/data/inputs/monitor/_reload"
        if [[ "$?" -eq 0 ]]; then
                log "[CHANGE] Successfully removed splunk monitor .. ok"
        else
                log "ERROR removing splunk monior!"
                return 1
        fi

        return 0
}

check_splunk_monitor() {
        local PUID=$1

        log "Checking splunk monitor for /applogs/${PUID}"
        splunk_api GET "/services/properties/inputs/monitor%3A%2F%2F%2Fapplogs%2F${PUID}"
        return $?
}


# Get kubernetes namespace and pod and then make sure we have a ro logging mount created.
check_logging_mirror() {
        local VOL=$1

        local MNTPATH=$(cat ${VOL}/mountpath)
        local PODUID=${MNTPATH%%/volumes/*}
        local PODUID=${PODUID##*/}
        local LOGMOUNT="${LOGGING_PATH}/${PODUID}"
        [[ ! -d "${LOGMOUNT}" ]] && mkdir -p ${LOGMOUNT}

        if ! ismounted ${LOGMOUNT}; then
                log "[CHANGE] Bind mounting ${VOL} to ${LOGMOUNT}"
                mount -o rbind ${VOL}/vmount ${LOGMOUNT}
                if [[ "$?" -ne 0 ]]; then
                        log "Error creating logging mirror mount!"
                        return 1
                fi
        fi

        # check that splunk is monitoring this volume.
        if ! check_splunk_monitor ${PODUID}; then
                configure_splunk_monitor ${VOL} ${PODUID}
        fi

        return 0
}

# when a sparse volume is removed we need to make sure that it's logging mount is also removed.
remove_logging_mirror() {
        local VOL=$1

        local MNTPATH=$(cat ${VOL}/mountpath)
        local PODUID=${MNTPATH%%/volumes/*}
        local PODUID=${PODUID##*/}
        local LOGMOUNT="${LOGGING_PATH}/${PODUID}"

        remove_splunk_monitor ${PODUID}
        if ismounted ${LOGMOUNT}; then
                log "[CHANGE] Un-mounting and removing ${LOGMOUNT}"
                umount -l ${LOGMOUNT}
                rm -rf ${LOGMOUNT}
        fi
}


# main loop of program (will break out if RUN_LOOP_DELAY is not set)
while true; do
        log "*** "
        log "*** Running bounded-local-controller main loop over ${VOLUME_PATH} "
        log "*** "
        for VOL in ${VOLUME_PATH}/*
        do
                [[ "${VOL}" =~ \*$ ]] && break

                SHORTVOL=${VOL%%/sparse-volume}
                SHORTVOL=${VOL##*/}

                [[ ! -f "${VOL}/status" || ! -f "${VOL}/mountpath" ]] && continue
                STATUS=$(cat ${VOL}/status | awk '{print $1}')
                WHEN=$(cat ${VOL}/status | awk '{print $2}')
                MNTPATH=$(cat ${VOL}/mountpath)

		# always maintain logging mirror regarless of volume status (to give short lived pods a chance to log)
                if [[ -f "${VOL}/mirror" ]]; then
                	[[ $(cat "${VOL}/mirror") == "true" ]] && check_logging_mirror ${VOL}
                fi

                case ${STATUS} in
                  mounted) log "${SHORTVOL} ${STATUS} since $(date -d @${WHEN} +'%Y/%m/%d %H:%M:%S')"

                           if ! ismounted ${MNTPATH}; then
                                   log "ERROR! ${SHORTVOL} is not correctly mounted to $MNTPATH, marking as failed!"
                                   TIMENOW=$(date +%s)
                                   echo "failed ${TIMENOW}" >${VOL}/status
                           fi
                           ;;

                  failed|unmounted)
                           DELAY=$(cat ${VOL}/cleanup_delay)
                           EXPIRES=$((${WHEN} + ${DELAY}))
                           TIMENOW=$(date +%s)
                           if [[ ${EXPIRES} -lt ${TIMENOW} ]]; then
                                  EXPIREDTIME=$((${TIMENOW} - ${EXPIRES}))
                                  log "Expired ${SHORTVOL} expired ${EXPIREDTIME} seconds ago"
                                  if ismounted ${VOL}/vmount; then
                                        log "[CHANGE] Un-mounting ${VOL}/vmount"
                                        umount -l ${VOL}/vmount
                                  fi

                                  if [[ -f "${VOL}/mirror" ]]; then
                                        # remove logging mirror if set to true
                                        [[ $(cat "${VOL}/mirror") == "true" ]] && remove_logging_mirror ${VOL}
                                  fi
                                  log "[CHANGE] Removing volume path: rm -rf ${VOLUME_PATH}/${SHORTVOL}"
                                  rm -rf ${VOLUME_PATH}/${SHORTVOL}
                           else
                                  TOGO=$((${EXPIRES} - ${TIMENOW}))
                                  log "${STATUS} ${SHORTVOL} has ${TOGO} secs until expiry."
                           fi
                           ;;
                  *)       log "ERROR - unknown status ${STATUS}!!!"
                           ;;
                esac
        done

        # exit loop if RUN_LOOP_DELAY not set
        [[ -z "${RUN_LOOP_DELAY}" ]] && break
        sleep ${RUN_LOOP_DELAY}
done

exit 0

